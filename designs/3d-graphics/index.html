<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Libraries</title>
        <!-- description: Live interactive demonstrations-->

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            padding: 60px 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 12px;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: #888;
            font-size: 1rem;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }

        @media (max-width: 1200px) {
            .demo-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 640px) {
            .demo-grid {
                grid-template-columns: 1fr;
            }
        }

        .demo-card {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .demo-card:hover {
            border-color: #3a3a3a;
            transform: translateY(-2px);
        }

        .demo-canvas-wrapper {
            width: 100%;
            height: 280px;
            background: #0a0a0a;
            position: relative;
            overflow: hidden;
        }

        .demo-canvas-wrapper canvas,
        .demo-canvas-wrapper svg {
            width: 100%;
            height: 100%;
        }

        .demo-info {
            padding: 16px;
        }

        .demo-library {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666;
            margin-bottom: 6px;
        }

        .demo-title {
            font-size: 1rem;
            font-weight: 500;
            color: #fff;
        }

        .library-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-threejs { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .badge-zdog { background: rgba(236, 72, 153, 0.2); color: #f472b6; }
        .badge-p5 { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }
        .badge-babylon { background: rgba(16, 185, 129, 0.2); color: #34d399; }
        .badge-d3 { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .badge-aframe { background: rgba(217, 70, 239, 0.2); color: #e879f9; }
        .badge-cannon { background: rgba(239, 68, 68, 0.2); color: #f87171; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>3D Graphics Libraries</h1>
            <p class="subtitle">Live interactive demonstrations</p>
        </header>

        <div class="demo-grid">
            <!-- Three.js Demo 1 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="three-matrix"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-threejs">Three.js</div>
                    <div class="demo-title">Matrix Rain</div>
                </div>
            </div>

            <!-- Three.js Demo 2 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="three-wireframe"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-threejs">Three.js</div>
                    <div class="demo-title">Neon Wireframe</div>
                </div>
            </div>

            <!-- Zdog Demo 1 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="zdog-crystal"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-zdog">Zdog</div>
                    <div class="demo-title">Crystal Gem</div>
                </div>
            </div>

            <!-- Zdog Demo 2 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="zdog-city"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-zdog">Zdog</div>
                    <div class="demo-title">Isometric City</div>
                </div>
            </div>

            <!-- P5.js Demo 1 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper" id="p5-neural"></div>
                <div class="demo-info">
                    <div class="library-badge badge-p5">P5.js</div>
                    <div class="demo-title">Neural Network</div>
                </div>
            </div>

            <!-- P5.js Demo 2 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper" id="p5-glitch"></div>
                <div class="demo-info">
                    <div class="library-badge badge-p5">P5.js</div>
                    <div class="demo-title">Glitch Art</div>
                </div>
            </div>

            <!-- Babylon.js Demo 1 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="babylon-holo"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-babylon">Babylon.js</div>
                    <div class="demo-title">Hologram Cube</div>
                </div>
            </div>

            <!-- Babylon.js Demo 2 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="babylon-particles"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-babylon">Babylon.js</div>
                    <div class="demo-title">Particle Burst</div>
                </div>
            </div>

            <!-- D3.js Demo 1 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper" id="d3-network"></div>
                <div class="demo-info">
                    <div class="library-badge badge-d3">D3.js</div>
                    <div class="demo-title">Network Graph</div>
                </div>
            </div>

            <!-- D3.js Demo 2 -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper" id="d3-dataflow"></div>
                <div class="demo-info">
                    <div class="library-badge badge-d3">D3.js</div>
                    <div class="demo-title">Data Stream</div>
                </div>
            </div>

            <!-- A-Frame Demo -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <a-scene id="aframe-scene" embedded style="width: 100%; height: 100%;">
                        <!-- Central energy orb -->
                        <a-sphere id="energy-core" position="0 0 -5" radius="0.5" color="#ff0080" opacity="0.8"
                            animation="property: rotation; to: 360 360 360; loop: true; dur: 3000"
                            animation__glow="property: components.material.material.emissive; to: #ff0080; dur: 1500; dir: alternate; loop: true">
                        </a-sphere>
                        
                        <!-- Orbiting particles -->
                        <a-entity id="orbit-container" position="0 0 -5"
                            animation="property: rotation; to: 0 360 0; loop: true; dur: 8000; easing: linear">
                            <a-sphere position="2 0 0" radius="0.1" color="#00ffff" opacity="0.9"></a-sphere>
                            <a-sphere position="-2 0 0" radius="0.1" color="#ffff00" opacity="0.9"></a-sphere>
                            <a-sphere position="0 2 0" radius="0.1" color="#ff4000" opacity="0.9"></a-sphere>
                            <a-sphere position="0 -2 0" radius="0.1" color="#8000ff" opacity="0.9"></a-sphere>
                        </a-entity>
                        
                        <!-- Pulsing rings -->
                        <a-ring id="ring1" position="0 0 -5" radius-inner="1" radius-outer="1.2" color="#00ff80" opacity="0.4"
                            animation="property: scale; to: 2 2 2; dur: 2000; dir: alternate; loop: true; easing: easeInOutSine"
                            animation__rotate="property: rotation; to: 360 0 360; loop: true; dur: 5000">
                        </a-ring>
                        <a-ring id="ring2" position="0 0 -5" radius-inner="1.5" radius-outer="1.7" color="#ff8000" opacity="0.3"
                            animation="property: scale; to: 1.5 1.5 1.5; dur: 3000; dir: alternate; loop: true; easing: easeInOutSine; delay: 1000"
                            animation__rotate="property: rotation; to: -360 360 -360; loop: true; dur: 7000">
                        </a-ring>
                        
                        <!-- Floating crystals -->
                        <a-box id="crystal1" position="3 1 -6" width="0.3" height="0.8" depth="0.3" color="#ff00ff" opacity="0.7"
                            animation="property: position; to: -3 -1 -4; dur: 6000; dir: alternate; loop: true; easing: easeInOutQuad"
                            animation__rotate="property: rotation; to: 180 360 180; loop: true; dur: 4000">
                        </a-box>
                        <a-box id="crystal2" position="-3 -1 -4" width="0.3" height="0.8" depth="0.3" color="#00ffff" opacity="0.7"
                            animation="property: position; to: 3 1 -6; dur: 6000; dir: alternate; loop: true; easing: easeInOutQuad; delay: 3000"
                            animation__rotate="property: rotation; to: -180 -360 -180; loop: true; dur: 4000">
                        </a-box>
                        
                        <a-sky color="#000011"></a-sky>
                        <a-light type="ambient" color="#220044" intensity="0.3"></a-light>
                        <a-light type="point" position="0 0 -3" color="#ff0080" intensity="0.8"></a-light>
                    </a-scene>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-aframe">A-Frame</div>
                    <div class="demo-title">Cosmic Energy</div>
                </div>
            </div>

            <!-- Cannon.js Demo -->
            <div class="demo-card">
                <div class="demo-canvas-wrapper">
                    <canvas id="cannon-physics"></canvas>
                </div>
                <div class="demo-info">
                    <div class="library-badge badge-cannon">Cannon.js</div>
                    <div class="demo-title">Gravity Storm</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // Three.js Demo 1: Matrix Rain
        {
            const canvas = document.getElementById('three-matrix');
            const parentWidth = canvas.parentElement.clientWidth;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, parentWidth / 280, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });

            renderer.setSize(parentWidth, 280);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            camera.position.z = 15;

            const particles = new THREE.BufferGeometry();
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 30;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 30;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 30;
                velocities.push(Math.random() * 0.1 + 0.05);
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });

            const particleSystem = new THREE.Points(particles, material);
            scene.add(particleSystem);

            function animateMatrix() {
                requestAnimationFrame(animateMatrix);

                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 1] -= velocities[i];
                    if (positions[i * 3 + 1] < -15) {
                        positions[i * 3 + 1] = 15;
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.rotation.y += 0.001;

                renderer.render(scene, camera);
            }
            animateMatrix();
        }

        // Three.js Demo 2: Neon Wireframe
        {
            const canvas = document.getElementById('three-wireframe');
            const parentWidth = canvas.parentElement.clientWidth;
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, parentWidth / 280, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });

            renderer.setSize(parentWidth, 280);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            camera.position.z = 5;

            const geometry = new THREE.IcosahedronGeometry(2, 0);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({
                color: 0xff00ff,
                linewidth: 2
            });
            const wireframe = new THREE.LineSegments(edges, material);
            scene.add(wireframe);

            const innerGeometry = new THREE.IcosahedronGeometry(1.5, 0);
            const innerEdges = new THREE.EdgesGeometry(innerGeometry);
            const innerMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                linewidth: 2
            });
            const innerWireframe = new THREE.LineSegments(innerEdges, innerMaterial);
            scene.add(innerWireframe);

            function animateWireframe() {
                requestAnimationFrame(animateWireframe);
                wireframe.rotation.x += 0.01;
                wireframe.rotation.y += 0.01;
                innerWireframe.rotation.x -= 0.015;
                innerWireframe.rotation.y -= 0.015;
                renderer.render(scene, camera);
            }
            animateWireframe();
        }
    </script>

    <!-- Zdog -->
    <script src="https://unpkg.com/zdog@1/dist/zdog.dist.min.js"></script>
    <script>
        // Zdog Demo 1: Crystal
        {
            const canvas = document.getElementById('zdog-crystal');
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = 280;

            const illo = new Zdog.Illustration({
                element: canvas,
                zoom: 3,
                dragRotate: true,
            });

            const crystal = new Zdog.Anchor({
                addTo: illo,
            });

            // Create diamond/crystal shape
            const colors = ['#ec4899', '#8b5cf6', '#06b6d4', '#f59e0b'];

            for (let i = 0; i < 4; i++) {
                new Zdog.Cone({
                    addTo: crystal,
                    diameter: 40,
                    length: 50,
                    stroke: false,
                    color: colors[i],
                    fill: true,
                    rotate: { y: (Math.PI / 2) * i },
                });
            }

            new Zdog.Cone({
                addTo: crystal,
                diameter: 40,
                length: 30,
                stroke: false,
                color: '#ec4899',
                fill: true,
                rotate: { x: Math.PI },
            });

            function animateCrystal() {
                illo.rotate.y += 0.02;
                illo.rotate.x = Math.sin(Date.now() * 0.001) * 0.3;
                illo.updateRenderGraph();
                requestAnimationFrame(animateCrystal);
            }
            animateCrystal();
        }

        // Zdog Demo 2: Isometric City
        {
            const canvas = document.getElementById('zdog-city');
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = 280;

            const illo = new Zdog.Illustration({
                element: canvas,
                zoom: 1.8,
                rotate: { x: -0.6, y: 0.6 },
            });

            // Create buildings
            const buildings = [
                { x: -40, z: -40, h: 50, color: '#3b82f6' },
                { x: 0, z: -40, h: 35, color: '#8b5cf6' },
                { x: 40, z: -40, h: 45, color: '#ec4899' },
                { x: -40, z: 0, h: 40, color: '#06b6d4' },
                { x: 0, z: 0, h: 60, color: '#f59e0b' },
                { x: 40, z: 0, h: 30, color: '#10b981' },
                { x: -40, z: 40, h: 48, color: '#8b5cf6' },
                { x: 0, z: 40, h: 35, color: '#3b82f6' },
                { x: 40, z: 40, h: 42, color: '#ec4899' },
            ];

            buildings.forEach(b => {
                new Zdog.Box({
                    addTo: illo,
                    width: 28,
                    height: b.h,
                    depth: 28,
                    translate: { x: b.x, y: 0, z: b.z },
                    stroke: 2,
                    color: b.color,
                    fill: true,
                    leftFace: b.color,
                    rightFace: b.color,
                    topFace: '#ffffff',
                    bottomFace: '#000000',
                });
            });

            illo.updateRenderGraph();

            function animateCity() {
                illo.rotate.y += 0.005;
                illo.updateRenderGraph();
                requestAnimationFrame(animateCity);
            }
            animateCity();
        }
    </script>

    <!-- P5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script>
        // P5.js Demo 1: Neural Network
        const neuralSketch = (p) => {
            let nodes = [];
            let connections = [];

            p.setup = () => {
                const container = document.getElementById('p5-neural');
                const canvas = p.createCanvas(container.clientWidth, 280);
                canvas.parent('p5-neural');

                // Create nodes
                for (let i = 0; i < 30; i++) {
                    nodes.push({
                        x: p.random(p.width),
                        y: p.random(p.height),
                        vx: p.random(-0.5, 0.5),
                        vy: p.random(-0.5, 0.5),
                    });
                }
            };

            p.draw = () => {
                p.background(10);

                // Update and draw nodes
                nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;

                    if (node.x < 0 || node.x > p.width) node.vx *= -1;
                    if (node.y < 0 || node.y > p.height) node.vy *= -1;

                    p.fill(139, 92, 246);
                    p.noStroke();
                    p.circle(node.x, node.y, 6);
                });

                // Draw connections
                p.stroke(139, 92, 246, 30);
                p.strokeWeight(1);
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const d = p.dist(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                        if (d < 100) {
                            p.line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                        }
                    }
                }
            };
        };

        // P5.js Demo 2: Glitch Art
        const glitchSketch = (p) => {
            let offset = 0;

            p.setup = () => {
                const container = document.getElementById('p5-glitch');
                const canvas = p.createCanvas(container.clientWidth, 280);
                canvas.parent('p5-glitch');
            };

            p.draw = () => {
                p.background(10);

                p.push();
                p.translate(p.width / 2, p.height / 2);

                for (let i = 0; i < 20; i++) {
                    p.push();
                    p.rotate(offset + i * 0.2);

                    // RGB shift effect
                    p.fill(255, 0, 0, 50);
                    p.rect(0, 0, 100 + i * 5, 5);

                    p.fill(0, 255, 0, 50);
                    p.rect(2, 0, 100 + i * 5, 5);

                    p.fill(0, 0, 255, 50);
                    p.rect(-2, 0, 100 + i * 5, 5);

                    p.pop();
                }

                p.pop();

                offset += 0.02;

                // Random glitch bars
                if (p.random() > 0.95) {
                    p.fill(255, 0, 255, 150);
                    p.noStroke();
                    p.rect(0, p.random(p.height), p.width, 2);
                }
            };
        };

        new p5(neuralSketch);
        new p5(glitchSketch);
    </script>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        // Babylon.js Demo 1: Hologram
        {
            const canvas = document.getElementById('babylon-holo');
            const engine = new BABYLON.Engine(canvas, true);

            const createScene = () => {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0.04, 0.04, 0.04, 1);

                const camera = new BABYLON.ArcRotateCamera(
                    "camera",
                    0, 1, 10,
                    BABYLON.Vector3.Zero(),
                    scene
                );

                const box = BABYLON.MeshBuilder.CreateBox("box", { size: 2 }, scene);

                const material = new BABYLON.StandardMaterial("material", scene);
                material.emissiveColor = new BABYLON.Color3(0, 1, 1);
                material.wireframe = true;
                box.material = material;

                // Animate
                scene.registerBeforeRender(() => {
                    box.rotation.y += 0.01;
                    box.rotation.x += 0.005;

                    // Pulse effect
                    const scale = 1 + Math.sin(Date.now() * 0.002) * 0.1;
                    box.scaling = new BABYLON.Vector3(scale, scale, scale);
                });

                return scene;
            };

            const scene = createScene();

            // Properly size the canvas
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = 280;
            engine.resize();

            engine.runRenderLoop(() => scene.render());
        }

        // Babylon.js Demo 2: Particles
        {
            const canvas = document.getElementById('babylon-particles');
            const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            const createScene = () => {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0.04, 0.04, 0.04, 1);

                const camera = new BABYLON.ArcRotateCamera(
                    "camera",
                    0, Math.PI / 3, 10,
                    BABYLON.Vector3.Zero(),
                    scene
                );

                const particleSystem = new BABYLON.ParticleSystem("particles", 1500, scene);
                particleSystem.particleTexture = new BABYLON.Texture(
                    "https://www.babylonjs-playground.com/textures/flare.png",
                    scene
                );

                particleSystem.emitter = new BABYLON.Vector3(0, -2, 0);
                particleSystem.minEmitBox = new BABYLON.Vector3(-0.5, 0, -0.5);
                particleSystem.maxEmitBox = new BABYLON.Vector3(0.5, 0, 0.5);

                particleSystem.color1 = new BABYLON.Color4(0.1, 0.9, 0.3, 1.0);
                particleSystem.color2 = new BABYLON.Color4(0.2, 1.0, 0.6, 1.0);
                particleSystem.colorDead = new BABYLON.Color4(0, 0.2, 0, 0.0);

                particleSystem.minSize = 0.2;
                particleSystem.maxSize = 0.5;

                particleSystem.minLifeTime = 0.8;
                particleSystem.maxLifeTime = 2.0;

                particleSystem.emitRate = 400;

                particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

                particleSystem.gravity = new BABYLON.Vector3(0, -5, 0);

                particleSystem.direction1 = new BABYLON.Vector3(-3, 10, -3);
                particleSystem.direction2 = new BABYLON.Vector3(3, 12, 3);

                particleSystem.minAngularSpeed = 0;
                particleSystem.maxAngularSpeed = Math.PI;

                particleSystem.minEmitPower = 3;
                particleSystem.maxEmitPower = 6;
                particleSystem.updateSpeed = 0.015;

                particleSystem.start();

                return scene;
            };

            const scene = createScene();

            // Properly size the canvas
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = 280;
            engine.resize();

            engine.runRenderLoop(() => scene.render());
        }
    </script>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // D3.js Demo 1: Network Graph
        {
            const container = document.getElementById('d3-network');
            const width = container.clientWidth;
            const height = 280;

            const svg = d3.select('#d3-network')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const nodes = d3.range(20).map(i => ({ id: i }));
            const links = d3.range(30).map(() => ({
                source: Math.floor(Math.random() * 20),
                target: Math.floor(Math.random() * 20)
            }));

            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(50))
                .force('charge', d3.forceManyBody().strength(-100))
                .force('center', d3.forceCenter(width / 2, height / 2));

            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .attr('stroke', '#f59e0b')
                .attr('stroke-opacity', 0.3)
                .attr('stroke-width', 1);

            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', 4)
                .attr('fill', '#fbbf24');

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
            });
        }

        // D3.js Demo 2: Data Stream
        {
            const container = document.getElementById('d3-dataflow');
            const width = container.clientWidth;
            const height = 280;

            const svg = d3.select('#d3-dataflow')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const data = d3.range(50).map(() => ({
                x: Math.random() * width,
                y: Math.random() * height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                r: Math.random() * 3 + 1
            }));

            const circles = svg.selectAll('circle')
                .data(data)
                .enter()
                .append('circle')
                .attr('r', d => d.r)
                .attr('fill', '#f59e0b')
                .attr('opacity', 0.6);

            function animate() {
                data.forEach(d => {
                    d.x += d.vx;
                    d.y += d.vy;

                    if (d.x < 0 || d.x > width) d.vx *= -1;
                    if (d.y < 0 || d.y > height) d.vy *= -1;
                });

                circles
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                requestAnimationFrame(animate);
            }
            animate();
        }
    </script>

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script>
        // A-Frame animations are handled declaratively in the HTML above
        // Additional dynamic effects
        document.addEventListener('DOMContentLoaded', () => {
            // Add particle trail effect
            setTimeout(() => {
                const scene = document.querySelector('#aframe-scene');
                if (scene) {
                    for (let i = 0; i < 20; i++) {
                        const particle = document.createElement('a-sphere');
                        particle.setAttribute('position', {
                            x: (Math.random() - 0.5) * 10,
                            y: (Math.random() - 0.5) * 10,
                            z: -8 + (Math.random() * 4)
                        });
                        particle.setAttribute('radius', Math.random() * 0.05 + 0.02);
                        particle.setAttribute('color', `hsl(${Math.random() * 360}, 70%, 60%)`);
                        particle.setAttribute('opacity', 0.6);
                        particle.setAttribute('animation', {
                            property: 'position',
                            to: `${(Math.random() - 0.5) * 10} ${(Math.random() - 0.5) * 10} ${-3 + (Math.random() * 4)}`,
                            dur: 5000 + Math.random() * 3000,
                            loop: true,
                            dir: 'alternate',
                            easing: 'easeInOutSine'
                        });
                        scene.appendChild(particle);
                    }
                }
            }, 1000);
        });
    </script>

    <!-- Cannon.js Physics -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.20.0/build/cannon.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        
        // Cannon.js Demo: Gravity Storm - Dynamic gravitational effects
        {
            const canvas = document.getElementById('cannon-physics');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, canvas.parentElement.clientWidth / 280, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
            
            renderer.setSize(canvas.parentElement.clientWidth, 280);
            renderer.setClearColor(0x000000, 0);
            
            // Physics world with variable gravity
            const world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            
            // Invisible attractors for interesting movement
            const attractors = [];
            for (let i = 0; i < 3; i++) {
                attractors.push({
                    position: new CANNON.Vec3(
                        (Math.random() - 0.5) * 8,
                        Math.random() * 6 + 2,
                        (Math.random() - 0.5) * 8
                    ),
                    strength: 20 + Math.random() * 30
                });
            }
            
            // Floating objects with various shapes
            const objects = [];
            const geometries = [
                new THREE.SphereGeometry(0.3, 8, 6),
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.ConeGeometry(0.3, 0.6, 6),
                new THREE.OctahedronGeometry(0.4)
            ];
            
            function createFloatingObject() {
                const geomIndex = Math.floor(Math.random() * geometries.length);
                const geometry = geometries[geomIndex];
                
                // Physics shape based on geometry
                let shape;
                if (geomIndex === 0) shape = new CANNON.Sphere(0.3);
                else if (geomIndex === 1) shape = new CANNON.Box(new CANNON.Vec3(0.25, 0.25, 0.25));
                else shape = new CANNON.Sphere(0.3); // Approximate other shapes as spheres
                
                const body = new CANNON.Body({ mass: 0.5 });
                body.addShape(shape);
                body.position.set(
                    (Math.random() - 0.5) * 6,
                    8 + Math.random() * 4,
                    (Math.random() - 0.5) * 6
                );
                body.velocity.set(
                    (Math.random() - 0.5) * 4,
                    0,
                    (Math.random() - 0.5) * 4
                );
                world.add(body);
                
                // Visual mesh with dynamic material
                const hue = Math.random() * 360;
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue / 360, 0.8, 0.6),
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                scene.add(mesh);
                
                objects.push({ 
                    body, 
                    mesh, 
                    hue,
                    life: 0,
                    maxLife: 300 + Math.random() * 200
                });
            }
            
            // Particle system for trails
            const trailGeometry = new THREE.SphereGeometry(0.05, 6, 4);
            const trails = [];
            
            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0x202040, 0.4);
            scene.add(ambientLight);
            
            const pointLight1 = new THREE.PointLight(0xff4080, 1, 20);
            pointLight1.position.set(4, 6, 4);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4080ff, 1, 20);
            pointLight2.position.set(-4, 6, -4);
            scene.add(pointLight2);
            
            camera.position.set(6, 8, 10);
            camera.lookAt(0, 3, 0);
            
            // Create initial objects
            for (let i = 0; i < 8; i++) {
                createFloatingObject();
            }
            
            let time = 0;
            
            function animate() {
                time += 0.016;
                world.step(1/60);
                
                // Update attractor positions in circular motion
                attractors.forEach((attractor, i) => {
                    attractor.position.x = Math.cos(time * 0.3 + i * 2) * 3;
                    attractor.position.z = Math.sin(time * 0.3 + i * 2) * 3;
                });
                
                // Apply gravitational forces from attractors
                objects.forEach(({ body }) => {
                    attractors.forEach(attractor => {
                        const dx = attractor.position.x - body.position.x;
                        const dy = attractor.position.y - body.position.y;
                        const dz = attractor.position.z - body.position.z;
                        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (distance > 0.1) {
                            const force = attractor.strength / (distance * distance);
                            body.force.x += (dx / distance) * force;
                            body.force.y += (dy / distance) * force;
                            body.force.z += (dz / distance) * force;
                        }
                    });
                });
                
                // Update visual objects and create trails
                objects.forEach(({ body, mesh, hue, life, maxLife }, index) => {
                    mesh.position.copy(body.position);
                    mesh.quaternion.copy(body.quaternion);
                    
                    // Update color based on velocity
                    const speed = body.velocity.length();
                    const intensity = Math.min(speed / 10, 1);
                    mesh.material.color.setHSL((hue + time * 50) % 360 / 360, 0.8, 0.4 + intensity * 0.4);
                    
                    // Create trail particles
                    if (Math.random() < 0.3) {
                        const trailMaterial = new THREE.MeshBasicMaterial({
                            color: mesh.material.color.clone(),
                            transparent: true,
                            opacity: 0.6
                        });
                        const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                        trail.position.copy(body.position);
                        trail.life = 0;
                        trail.maxLife = 30;
                        scene.add(trail);
                        trails.push(trail);
                    }
                    
                    // Age and remove old objects
                    objects[index].life++;
                    if (life > maxLife || body.position.y < -5) {
                        world.remove(body);
                        scene.remove(mesh);
                        objects.splice(index, 1);
                    }
                });
                
                // Update and cleanup trails
                trails.forEach((trail, index) => {
                    trail.life++;
                    trail.material.opacity = 1 - (trail.life / trail.maxLife);
                    trail.scale.setScalar(1 - trail.life / trail.maxLife);
                    
                    if (trail.life >= trail.maxLife) {
                        scene.remove(trail);
                        trails.splice(index, 1);
                    }
                });
                
                // Spawn new objects periodically
                if (objects.length < 12 && Math.random() < 0.02) {
                    createFloatingObject();
                }
                
                // Animate lights
                pointLight1.position.x = Math.cos(time * 0.5) * 5;
                pointLight1.position.z = Math.sin(time * 0.5) * 5;
                pointLight2.position.x = Math.cos(time * 0.7 + Math.PI) * 4;
                pointLight2.position.z = Math.sin(time * 0.7 + Math.PI) * 4;
                
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            
            animate();
        }
    </script>
</body>
</html>